import * as fsSync from "fs";
import * as fs from "fs/promises";

import { CSharpOrganizeSettings } from "../CSharp/CSharpOrganizeSettings";
import { FileFilter } from "../Models/FileFilter";
import { CodingStyles } from "../Utils/CodingStyles";
import { SymbolRename } from "../Utils/SymbolRename";

export class CSharpenWorkspaceSettings {
    static readonly fileName = ".csharpen.json";

    public allowSharpenWithFileDiagnosticErrors: boolean | undefined;
    public autoGeneratedPatterns: string[] | undefined;
    public codingStyles: CodingStyles | undefined;
    public codingStylesEnabled: boolean | undefined;
    public delayBeforeDetectingFileDiagnostics: number | undefined;
    public delayBeforeRemovingUnusedUsingDirectives: number | undefined;
    public delayBeforeSharpeningFile: number | undefined;
    public doNotRemoveThesePackageReferences: string[] | undefined;
    public enforceFileScopedNamespaces: boolean | undefined;
    public fileFilters: FileFilter[] | undefined;
    public formatDocumentOnSharpen: boolean | undefined;
    public namespaceLevelOrganization: CSharpOrganizeSettings | undefined;
    public performQuickFixesOnSharpen: boolean | undefined;
    public quickFixesToPerform: string[] | undefined;
    public quickFixFilters: string[] | undefined;
    public regionalizeInterfaceImplementations: string[] | undefined;
    public removeUnusedUsingsOnSharpen: boolean | undefined;
    public sharpenFilesWhenRemovingUnusedReferences: boolean | undefined;
    public showFileSizeDifferenceOnSharpen: boolean | undefined;
    public skipAutoGeneratedFileWhenRemovingUnusedReferences: boolean | undefined;
    public symbolRenaming: SymbolRename[] | undefined;
    public symbolRenamingEnabled: boolean | undefined;
    public typeLevelOrganization: CSharpOrganizeSettings | undefined;

    public static readFile(workspaceFolder: string): CSharpenWorkspaceSettings | undefined {
        const filePath = workspaceFolder + "/" + this.fileName;

        try { fsSync.accessSync(filePath, fsSync.constants.R_OK); }
        catch { return undefined; }

        const workspaceSettingsInstance = new CSharpenWorkspaceSettings();
        const workspaceSettingsDeserialized = JSON.parse(fsSync.readFileSync(filePath, "utf8")) as CSharpenWorkspaceSettings;

        return Object.assign(workspaceSettingsInstance, workspaceSettingsDeserialized);
    }

    public static async readFileAsync(workspaceFolder: string): Promise<CSharpenWorkspaceSettings | undefined> {
        const filePath = workspaceFolder + "/" + this.fileName;

        try { await fs.access(filePath, fs.constants.R_OK); }
        catch { return undefined; }

        const workspaceSettingsInstance = new CSharpenWorkspaceSettings();
        const workspaceSettingsDeserialized = (await this.readFileAsJsonAsync(filePath)) as CSharpenWorkspaceSettings;

        return Object.assign(workspaceSettingsInstance, workspaceSettingsDeserialized);
    }

    private static async readFileAsJsonAsync(filePath: string): Promise<any> {
        return await fs.readFile(filePath).then(data => {
            return JSON.parse(Buffer.from(<Uint8Array>data).toString("utf8"));
        }).catch(() => {
            return undefined;
        });
    }
}
